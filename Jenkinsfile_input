//hardcoded json body in real scenario this would pulled down as a json file and assigned to variable
import groovy.json.JsonSlurper
/*
def url = new URL("https://storage.googleapis.com/tjohns-mysql-dump/query-results/query.json")
def json = url.getText()

def populateImages(jsonArray, environments) {
    def images = []
    if (environments.contains(Environment)) {
        images = jsonArray.findAll { it.ENV == environments }.collect { it.IMAGE }
    }
    return images ?: ['Not Applicable']
}

def populateVersions(jsonArray, environments, images) {
    def versions = []
    if (environments.contains(Environment) && images.contains(Image)) {
        versions = jsonArray.findAll { it.ENV == environments && it.IMAGE == images }.collect { it.VERSION }
    }
    return versions ?: ['Not Applicable']
}

def environments = ['DEV', 'STAGE', 'PROD']
def jsonSlurper = new JsonSlurper()
def jsonArray = jsonSlurper.parseText(json)

def images = populateImages(jsonArray, environments).inspect()
def versions = populateVersions(jsonArray, environments, images).inspect()
*/


properties([
    parameters([
        [$class: 'ChoiceParameter', choiceType: 'PT_SINGLE_SELECT',   name: 'Environment', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: 'return ["ERROR"]'], script: [classpath: [], sandbox: false, script: '''
            def environments = ["DEV", "STAGE", "PROD"]
            return environments
        ''']]],
        [$class: 'CascadeChoiceParameter', choiceType: 'PT_SINGLE_SELECT', name: 'Image', referencedParameters: 'Environment', script: [$class: 'GroovyScript', fallbackScript: [classpath: [], sandbox: false, script: 'return ["error"]'], script: [classpath: [], sandbox: false, script: '''
            def environmentValue = Environment.toString()
            
            def url = new URL("https://storage.googleapis.com/tjohns-mysql-dump/query-results/query.json")
            def json = url.getText()
            def jsonSlurper = new JsonSlurper()
            def jsonArray = jsonSlurper.parseText(json)
            
            def images = jsonArray.findAll { it.ENV == environmentValue }.collect { it.IMAGE }
            return images ?: ['Not Applicable']
        ''']]]
    ])
])


//define pipeline actions
pipeline {
    agent any

    stages{
        stage('Parameters') {
            steps {
                    echo 'building..'
            }
        }
    }
        // Add more stages as needed for your pipeline
}
